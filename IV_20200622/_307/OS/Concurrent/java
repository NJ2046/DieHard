jvm内存基础

程序计数器
程序计数器私有主要是为了线程切换后能够恢复到正确的执行位置。

虚拟机栈
每个Java 方法在执行的同时会创建一个帧栈用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至完成的过程，就对应一个帧栈在 Java 虚拟机中入栈和出栈的过程。

本地方法栈
和虚拟机的作用非常相似。区别是：虚拟机为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一

堆和方法区
堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用来存放新创建的对象(所有的对象都在这里分配内存)；方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。

线程的生命周期和状态
Java 线程在运行的生命周期中的指定时刻只可能指定处于下面几种不同状态的其中一个状态：

    新建状态(NEW)：新创建了一个线程对象；
    就绪状态(RUNNABLE)：线程创建后，其他线程调用了该对象的 start() 方法。该方法状态的线程位于可运行线程池中，变得可运行，等待获取 CPU 的使用权；
    运行状态(RUNNING)：就绪状态的线程获取了 CPU，执行程序代码；
    阻塞状态(BLOCKED)：阻塞状态是线程因为某种原因放弃 CPU 使用权，暂时停止运行。知道线程进入就绪状态，才有机会转到运行状态。阻塞的情况分为三种：
        等待阻塞：运行的线程执行 wait() 方法，JVM 会把该线程放入线程池中。
        同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池中。
        其他阻塞：运行的线程执行 sleep() 或 join() 方法，或者发出了 I/O 请求时，JVM 会把该线程设置为阻塞状态。当 sleep() 超时、join() 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。
    死亡状态(DEAD)：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期

状态之间的转换：线程创建之初处于 NEW (新建) 状态。调用 start() 方法后开始运行，线程这时候处于 READY (可运行) 状态。可运行状态的线程获得了 CPU 时间片 (timeslice) 后就处于 RUNNING (运行)状态。线程执行了 wait() 方法后，线程进入 WAITING (超时等待) 状态相当于等待状态的基础上增加了超时限制，比如 sleep(long millis) 方法或 waiting(long millis) 方法可以将 Java 线程置于 TIME WAITING 状态。当超时时间达到后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED (阻塞)状态。线程在执行 Runnable 的 run() 方法之后将进入到 TERMINATED (终止) 状态。



解决并发的一些思考
1. 多线程&队列
2. 缓存
3. 页面静态化

较优
1、采用分布式应用设计
2、分布式缓存数据库
3、代码优化